// console.log(a);
// var a = 10;
// console.log(a);

// console.log(a);-refernce error
// let a;
// console.log(a);
// let b = 100;
// console.log(b);
// let c = 10;
// c = 80;
// console.log(c);
// let v; //possible
// v = 70;
// console.log(v);
//const d; //not possible
// const g = 6;
//const g=5;//Syntax error
//g = 4; //type error
// console.log(g);
// function greet() {
//   console.log(message); // ❌ ReferenceError
//   var message = "Hi!";
// }
// console.log(message);
// greet();

// scope of let,var,
// if (a) console.log("Valid Namaste for Var"); //as undefined no o/p
// // if (b) console.log("InValid Namaste for let");
// //if (c) console.log("Valid Namaste for const");
// var a = true;
// if (a) console.log("Namaste by Var");
// let d = false;
// d = true;
// if (d) console.log("Namaste by Let");
// const o = false;
// if (o) console.log("Namaste");

// // When you use var in the global context, the variable becomes accessible everywhere.

// // But within functions, var stays local to the function — that’s what makes it function-scoped.
